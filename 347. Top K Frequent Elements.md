## [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/description/)

### Description

Given a non-empty array of integers, return the **k** most frequent elements.

For example,
Given `[1,1,1,2,2,3]` and k = 2, return `[1,2]`.

**Note: **

- You may assume *k* is always valid, 1 ? *k* ? number of unique elements.
- Your algorithm's time complexity **must be** better than O(*n* log *n*), where *n* is the array's size.



**Difficult:** `Medium`

**Tags:** `Hash Table` `Heap`



### Solution One

来源于题目 [451. Sort Characters By Frequency](https://leetcode.com/problems/sort-characters-by-frequency/discuss/) 的 Top Solutions: [C++ O(n) solution without sort()](https://discuss.leetcode.com/topic/66045/c-o-n-solution-without-sort)

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        int maxFreq;
        for (auto i : nums)
        {
            ++freq[i];
            maxFreq = max(maxFreq, freq[i]);
        }
        vector<vector<int>> bucket(maxFreq + 1);
        for (auto iter : freq)
            bucket[iter.second].push_back(iter.first);

        vector<int> res;
        int count = 0;
        auto iter = bucket.rbegin();
        while (iter != bucket.rend() && count < k)
        {
            if (!iter->empty())
            {
                res.push_back(iter->back());
                iter->pop_back();
                count++;
            }
            else
            {
                iter++;
            }
        }
        return res;
    }
};
```



